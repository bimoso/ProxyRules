using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;
using Titanium.Web.Proxy;
using Titanium.Web.Proxy.EventArguments;
using Titanium.Web.Proxy.Models;
using Titanium.Web.Proxy.Network.Certificate; // Added this line
using System.Net.Security;
using System.Linq;
using Microsoft.Win32;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Runtime.Versioning;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;

public class ApiEndpoint
{
    public required string HostPattern { get; set; } // Nuevo campo para el dominio
    public required string UrlPattern { get; set; }
    public required Func<dynamic> ResponseGenerator { get; set; }
    public string HttpMethod { get; set; } = "GET"; // Valor por defecto GET
    public string MatchType { get; set; } = "Exacto"; // Valor por defecto Exacto
    public bool IsEnabled { get; set; } = true; // Valor por defecto true
}

public class ProxyManager : IDisposable
{
    private readonly ProxyServer proxyServer;
    private readonly Dictionary<string, ApiEndpoint> endpoints;
    private readonly int proxyPort;
    private bool proxyEnabled = false;

    [DllImport("wininet.dll")]
    private static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);

    private const int INTERNET_OPTION_SETTINGS_CHANGED = 39;
    private const int INTERNET_OPTION_REFRESH = 37;

    public ProxyManager(int port = 8060)
    {
        proxyServer = new ProxyServer(false);
        endpoints = new Dictionary<string, ApiEndpoint>();
        proxyPort = port;

        // Inicializar el RootCertificate en el constructor
        ConfigureSSL();
    }

    public void AddEndpoint(string name, ApiEndpoint endpoint)
    {
        if (endpoint.IsEnabled)
        {
            endpoints[name] = endpoint;
        }
    }

    [SupportedOSPlatform("windows")]
    private void SetWindowsProxy(bool enable)
    {
        const int maxRetries = 3;
        int attempt = 0;
        bool success = false;

        while (attempt < maxRetries && !success)
        {
            try
            {
                const string userRoot = "HKEY_CURRENT_USER";
                const string subKey = @"Software\Microsoft\Windows\CurrentVersion\Internet Settings";
                const string keyName = userRoot + "\\" + subKey;

                if (enable)
                {
                    Registry.SetValue(keyName, "ProxyEnable", 1);
                    Registry.SetValue(keyName, "ProxyServer", $"127.0.0.1:{proxyPort}");
                    Console.WriteLine($"Proxy configured at: 127.0.0.1:{proxyPort}");
                }
                else
                {
                    Registry.SetValue(keyName, "ProxyEnable", 0);
                    Registry.SetValue(keyName, "ProxyServer", ""); // Limpiar ProxyServer
                    Registry.SetValue(keyName, "AutoConfigURL", ""); // Limpiar AutoConfigURL
                    Registry.SetValue(keyName, "ProxyOverride", ""); // Limpiar ProxyOverride
                    Console.WriteLine("Proxy disabled y configuraciones adicionales limpiadas.");
                }

                proxyEnabled = enable;
                success = true;

                // Forzar la actualización de la configuración
                InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);
                InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);
            }
            catch (Exception ex)
            {
                attempt++;
                LogError($"Error configuring Windows proxy (Attempt {attempt}/{maxRetries})", ex);
                if (attempt >= maxRetries)
                {
                    throw;
                }
            }
        }
    }

    private void ExportRootCertificate()
    {
        var cert = proxyServer.CertificateManager.RootCertificate;
        if (cert == null)
        {
            Console.WriteLine("RootCertificate no está inicializado. Creando certificado raíz...");
            proxyServer.CertificateManager.CreateRootCertificate(false);
            proxyServer.CertificateManager.TrustRootCertificate(true);
            cert = proxyServer.CertificateManager.RootCertificate;
            if (cert == null)
            {
                Console.WriteLine("Error: No se pudo crear el certificado raíz.");
                return;
            }
        }

        string certPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "rootCert.cer");
        File.WriteAllBytes(certPath, cert.Export(X509ContentType.Cert));
        Console.WriteLine($"Certificado exportado a: {certPath}");
    }

    private bool IsCertificateInstalled(bool isLocalMachine)
    {
        var storeName = StoreName.Root;
        var storeLocation = isLocalMachine ? StoreLocation.LocalMachine : StoreLocation.CurrentUser;
        using var store = new X509Store(storeName, storeLocation);
        store.Open(OpenFlags.ReadOnly);
        return store.Certificates
            .OfType<X509Certificate2>()
            .Any(cert => cert.Thumbprint.Equals(proxyServer.CertificateManager.RootCertificate.Thumbprint,
                StringComparison.OrdinalIgnoreCase));
    }

    private bool IsCertificateTrusted()
    {
        try
        {
            var cert = proxyServer.CertificateManager.RootCertificate;
            if (cert == null) return false;

            bool trustedInMachine = false;
            bool trustedInUser = false;

            // Verificar en LocalMachine
            using (var store = new X509Store(StoreName.Root, StoreLocation.LocalMachine))
            {
                store.Open(OpenFlags.ReadOnly);
                trustedInMachine = store.Certificates
                    .OfType<X509Certificate2>()
                    .Any(x => x.Thumbprint == cert.Thumbprint);
                store.Close();
            }

            // Verificar en CurrentUser
            using (var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser))
            {
                store.Open(OpenFlags.ReadOnly);
                trustedInUser = store.Certificates
                    .OfType<X509Certificate2>()
                    .Any(x => x.Thumbprint == cert.Thumbprint);
                store.Close();
            }

            return trustedInMachine || trustedInUser;
        }
        catch
        {
            return false;
        }
    }

    private void RegenerateRootCertificate()
    {
        try
        {
            // Eliminar el certificado raíz existente usando X509Store
            using (var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser))
            {
                store.Open(OpenFlags.ReadWrite);
                var existingCerts = store.Certificates
                    .Find(X509FindType.FindBySubjectName,
                        proxyServer.CertificateManager.RootCertificate.SubjectName.Name, false);

                foreach (var cert in existingCerts)
                {
                    store.Remove(cert);
                    Console.WriteLine("Certificado raíz existente eliminado del almacén de Usuario Actual.");
                }

                store.Close();
            }

            // Crear y confiar en un nuevo certificado raíz
            proxyServer.CertificateManager.CreateRootCertificate(false); // Crear nuevo certificado
            proxyServer.CertificateManager.TrustRootCertificate(true); // Confiar en el certificado
            Console.WriteLine("Certificado raíz regenerado y confiado correctamente.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error al regenerar el certificado raíz: {ex.Message}");
        }
    }

    private void InstallRootCertificate()
    {
        try
        {
            // Verificar si el proceso se está ejecutando como administrador
            if (!IsRunningAsAdmin())
            {
                Console.WriteLine("Advertencia: La aplicación no se está ejecutando con privilegios administrativos. Algunas operaciones pueden fallar.");
            }

            // Primero limpiamos certificados antiguos
            RemoveAllProxyCertificates();

            // Crear o obtener el certificado raíz
            var cert = proxyServer.CertificateManager.RootCertificate;
            if (cert == null || !IsCertificateTrusted())
            {
                Console.WriteLine("Creando nuevo certificado raíz...");
                proxyServer.CertificateManager.CreateRootCertificate(false);
                proxyServer.CertificateManager.TrustRootCertificate(true);
                cert = proxyServer.CertificateManager.RootCertificate;

                if (cert == null)
                {
                    throw new Exception("Error: No se pudo crear el certificado raíz.");
                }
            }

            bool isAdmin = IsRunningAsAdmin();

            // Intentar instalar en el almacén de Máquina Local (requiere admin)
            if (isAdmin)
            {
                try
                {
                    using var storeLocal = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
                    storeLocal.Open(OpenFlags.ReadWrite);
                    
                    // Verificar si ya existe
                    var existingCerts = storeLocal.Certificates
                        .Find(X509FindType.FindByThumbprint, cert.Thumbprint, false);

                    if (existingCerts.Count == 0)
                    {
                        storeLocal.Add(cert);
                        Console.WriteLine("Certificado raíz instalado en el almacén de Máquina Local.");
                    }
                    else
                    {
                        Console.WriteLine("El certificado raíz ya existe en el almacén de Máquina Local.");
                    }

                    storeLocal.Close();
                }
                catch (UnauthorizedAccessException)
                {
                    Console.WriteLine("Error al instalar en Máquina Local: Acceso denegado. Asegúrate de ejecutar la aplicación como administrador.");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error al instalar en Máquina Local: {ex.Message}");
                }
            }

            // Instalar en el almacén de Usuario Actual
            try
            {
                using var storeUser = new X509Store(StoreName.Root, StoreLocation.CurrentUser);
                storeUser.Open(OpenFlags.ReadWrite);

                // Verificar si ya existe
                var existingCerts = storeUser.Certificates
                    .Find(X509FindType.FindByThumbprint, cert.Thumbprint, false);

                if (existingCerts.Count == 0)
                {
                    storeUser.Add(cert);
                    Console.WriteLine("Certificado raíz instalado en el almacén de Usuario Actual.");
                }
                else
                {
                    Console.WriteLine("El certificado raíz ya existe en el almacén de Usuario Actual.");
                }

                storeUser.Close();
            }
            catch (UnauthorizedAccessException)
            {
                Console.WriteLine("Error al instalar en Usuario Actual: Acceso denegado. Verifica los permisos de tu usuario.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error al instalar en Usuario Actual: {ex.Message}");
            }

            // Verificar la instalación
            if (!IsCertificateTrusted())
            {
                Console.WriteLine("Advertencia: El certificado podría no estar correctamente confiado.");
                RegenerateRootCertificate();
            }

            // Información de diagnóstico
            Console.WriteLine($"Certificado Root Thumbprint: {cert.Thumbprint}");
            Console.WriteLine($"Certificado Root Subject: {cert.Subject}");
            Console.WriteLine($"Certificado Root Issuer: {cert.Issuer}");
            Console.WriteLine($"Válido desde: {cert.NotBefore}");
            Console.WriteLine($"Válido hasta: {cert.NotAfter}");

            // Verificar la instalación en ambos almacenes
            VerifyRootCertificateInstallation(cert);

            // Verificar la confianza del certificado en el navegador
            VerifyBrowserTrust(cert);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error crítico en InstallRootCertificate: {ex.Message}");
            Console.WriteLine(ex.StackTrace);
            throw;
        }
    }

    private void VerifyRootCertificateInstallation(X509Certificate2 cert)
    {
        bool isInstalledLocal = IsCertificateInstalled(true);
        bool isInstalledUser = IsCertificateInstalled(false);

        if (isInstalledLocal && isInstalledUser)
        {
            Console.WriteLine("Verificación Exitosa: Certificado raíz está instalado en ambos almacenes.");
        }
        else
        {
            Console.WriteLine(
                "Verificación Fallida: Certificado raíz no está instalado correctamente en uno o ambos almacenes.");
            if (!isInstalledLocal)
            {
                Console.WriteLine("Certificado no encontrado en el almacén de Máquina Local.");
            }
            if (!isInstalledUser)
            {
                Console.WriteLine("Certificado no encontrado en el almacén de Usuario Actual.");
            }
        }
    }

    private void VerifyBrowserTrust(X509Certificate2 cert)
    {
        try
        {
            using var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);
            var foundCerts = store.Certificates.Find(X509FindType.FindByThumbprint, cert.Thumbprint, false);
            if (foundCerts.Count > 0)
            {
                Console.WriteLine("El navegador confía en el certificado raíz.");
            }
            else
            {
                Console.WriteLine("El navegador no confía en el certificado raíz.");
            }
            store.Close();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error al verificar la confianza del navegador: {ex.Message}");
        }
    }

    public void RestoreCertificates()
    {
        try
        {
            RemoveOldCertificates();
            ConfigureSSL();
            Console.WriteLine("Certificados restaurados y configurados correctamente.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error al restaurar certificados: {ex.Message}");
            throw;
        }
    }

    public void DeleteCertificates()
    {
        try
        {
            RemoveAllProxyCertificates();
            Console.WriteLine("Todos los certificados de Titanium han sido eliminados.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error al eliminar los certificados: {ex.Message}");
            throw;
        }
    }

    public void GenerateCertificates()
    {
        try
        {
            ConfigureSSL();
            ExportRootCertificate();
            InstallRootCertificate();
            Console.WriteLine("Certificados generados y configurados correctamente.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error al generar los certificados: {ex.Message}");
            throw;
        }
    }

    private void RemoveInstalledCertificates()
    {
        bool isAdmin = IsRunningAsAdmin();
        var certToRemove = proxyServer.CertificateManager.RootCertificate;

        if (certToRemove == null)
        {
            Console.WriteLine("No se encontró el certificado raíz para eliminar.");
            return;
        }

        var thumbprint = certToRemove.Thumbprint;
        var subject = certToRemove.Subject;

        // Remover del almacén de Máquina Local si se ejecuta como administrador
        if (isAdmin)
        {
            if (IsCertificateInstalled(true))
            {
                using var store = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadWrite);
                var certs = store.Certificates.Find(X509FindType.FindByThumbprint, thumbprint, false)
                    .OfType<X509Certificate2>()
                    .Where(cert => cert.Subject == subject);
                foreach (var cert in certs)
                {
                    store.Remove(cert);
                    Console.WriteLine("Certificado removido del almacén de Máquina Local.");
                }

                store.Close();
            }
        }

        // Remover del almacén de Usuario Actual
        if (IsCertificateInstalled(false))
        {
            using var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadWrite);
            var certs = store.Certificates.Find(X509FindType.FindByThumbprint, thumbprint, false)
                .OfType<X509Certificate2>()
                .Where(cert => cert.Subject == subject);
            foreach (var cert in certs)
            {
                store.Remove(cert);
                Console.WriteLine("Certificado removido del almacén de Usuario Actual.");
            }

            store.Close();
        }
    }

    private void RemoveOldCertificates()
    {
        string certName = "Titanium Root Certificate Authority";

        // Llamar al método para eliminar certificados duplicados
        RemoveDuplicateCertificates(certName);

        string[] certNames = new[] { "Bypass-Exploits Proxy CA", certName };
        bool isAdmin = IsRunningAsAdmin();

        foreach (string name in certNames)
        {
            if (isAdmin)
            {
                using (var store = new X509Store(StoreName.Root, StoreLocation.LocalMachine))
                {
                    store.Open(OpenFlags.ReadWrite);
                    var certs = store.Certificates.Find(X509FindType.FindBySubjectName, name, false);
                    foreach (var cert in certs)
                    {
                        store.Remove(cert);
                        Console.WriteLine($"Certificado '{name}' removido del almacén de Máquina Local.");
                    }

                    store.Close();
                }
            }

            using (var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser))
            {
                store.Open(OpenFlags.ReadWrite);
                var certs = store.Certificates.Find(X509FindType.FindBySubjectName, name, false);
                foreach (var cert in certs)
                {
                    store.Remove(cert);
                    Console.WriteLine($"Certificado '{name}' removido del almacén de Usuario Actual.");
                }

                store.Close();
            }
        }
    }

    private void RemoveDuplicateCertificates(string certName)
    {
        bool isAdmin = IsRunningAsAdmin();

        // Remover duplicados del almacén de Máquina Local si es administrador
        if (isAdmin)
        {
            using (var store = new X509Store(StoreName.Root, StoreLocation.LocalMachine))
            {
                store.Open(OpenFlags.ReadWrite);
                var certs = store.Certificates.Find(X509FindType.FindBySubjectName, certName, false)
                    .OfType<X509Certificate2>()
                    .ToList();
                if (certs.Count > 1)
                {
                    // Mantener el primero y eliminar los demás
                    for (int i = 1; i < certs.Count; i++)
                    {
                        store.Remove(certs[i]);
                        Console.WriteLine($"Certificado duplicado '{certName}' removido del almacén de Máquina Local.");
                    }
                }

                store.Close();
            }
        }

        // Remover duplicados del almacén de Usuario Actual
        using (var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser))
        {
            store.Open(OpenFlags.ReadWrite);
            var certs = store.Certificates.Find(X509FindType.FindBySubjectName, certName, false)
                .OfType<X509Certificate2>()
                .ToList();
            if (certs.Count > 1)
            {
                // Mantener el primero y eliminar los demás
                for (int i = 1; i < certs.Count; i++)
                {
                    store.Remove(certs[i]);
                    Console.WriteLine($"Certificado duplicado '{certName}' removido del almacén de Usuario Actual.");
                }
            }

            store.Close();
        }
    }

    private bool IsRunningAsAdmin()
    {
        try
        {
            var identity = WindowsIdentity.GetCurrent();
            var principal = new WindowsPrincipal(identity);
            return principal.IsInRole(WindowsBuiltInRole.Administrator);
        }
        catch
        {
            return false;
        }
    }

    public async Task StartProxy()
    {
        try
        {
            // Verificar la existencia del certificado sin regenerarlo automáticamente
            if (!IsCertificateTrusted())
            {
                Console.WriteLine("Advertencia: El certificado raíz no está instalado o no es confiable.");
            }

            ConfigureProxyServer();
            await StartProxyServer();
            SetWindowsProxy(true);
            PrintStatus();
            Console.WriteLine("Testing proxy connection...");
            if (!await TestProxyConnection())
            {
                Console.WriteLine("Proxy connection failed. Disabling proxy and exiting.");
                SetWindowsProxy(false);
                Console.WriteLine(
                    "If the proxy does not work or leaves you without internet, please close and reopen the application.");
                return;
            }

            await WaitForEscKey();
        }
        catch (Exception ex)
        {
            LogError("Error starting proxy", ex);
            throw;
        }
        finally
        {
            Dispose();
        }
    }

    private async Task<bool> TestProxyConnection()
    {
        try
        {
            using (var client = new HttpClient(new HttpClientHandler
                       { Proxy = new WebProxy($"http://127.0.0.1:{proxyPort}") }))
            {
                await client.GetStringAsync("http://www.google.com");
            }

            Console.WriteLine("Proxy connection established successfully.");
            return true;
        }
        catch
        {
            return false;
        }
    }

    private void ConfigureSSL()
    {
        try
        {
            // Forzar la eliminación de certificados existentes primero
            RemoveAllProxyCertificates();

            ServicePointManager.SecurityProtocol =
                SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;

            // Forzar la creación de un nuevo certificado
            proxyServer.CertificateManager.CreateRootCertificate(false);

            // Esperar un momento para asegurar que el certificado se ha creado
            Thread.Sleep(1000);

            // Verificar que el certificado se creó correctamente
            if (proxyServer.CertificateManager.RootCertificate == null)
            {
                throw new Exception("Failed to create root certificate");
            }

            // Instalar el certificado en ambos almacenes
            try
            {
                InstallRootCertificate();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error en ConfigureSSL: {ex.Message}");
                throw;
            }

            // Confiar explícitamente en el certificado
            proxyServer.CertificateManager.TrustRootCertificate(true);

            proxyServer.ForwardToUpstreamGateway = true;
            Console.WriteLine("Configuración SSL completada correctamente.");

            // Verificar la instalación
            if (!IsCertificateTrusted())
            {
                throw new Exception("Certificate was not trusted after installation");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error en ConfigureSSL: {ex.Message}");
            throw;
        }
    }

    public void RemoveAllProxyCertificates()
    {
        try
        {
            string[] storeLocations = { "LocalMachine", "CurrentUser" };
            foreach (string location in storeLocations)
            {
                using (var store = new X509Store(StoreName.Root, 
                           location == "LocalMachine" ? StoreLocation.LocalMachine : StoreLocation.CurrentUser))
                {
                    store.Open(OpenFlags.ReadWrite);
                
                    // Buscar por nombre común
                    var certsToRemove = store.Certificates.Find(
                        X509FindType.FindBySubjectName, 
                        "Titanium Root Certificate Authority", 
                        false);
                
                    // Buscar también por thumbprint si existe
                    if (proxyServer.CertificateManager.RootCertificate != null)
                    {
                        var certsByThumbprint = store.Certificates.Find(
                            X509FindType.FindByThumbprint,
                            proxyServer.CertificateManager.RootCertificate.Thumbprint,
                            false);
                        certsToRemove.AddRange(certsByThumbprint);
                    }
                
                    foreach (var cert in certsToRemove)
                    {
                        store.Remove(cert);
                        Console.WriteLine($"Certificado '{cert.Subject}' removido del almacén de {location}.");
                    }
                
                    store.Close();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing certificates: {ex.Message}");
        }
    }

    private void InstallAndTrustCertificate(X509Certificate2 cert, string certificateName)
    {
        bool isAdmin = IsRunningAsAdmin();
        bool installed = false;

        // Instalar en LocalMachine si es administrador
        if (isAdmin)
        {
            try
            {
                using (var store = new X509Store(StoreName.Root, StoreLocation.LocalMachine))
                {
                    store.Open(OpenFlags.ReadWrite);
                    store.Add(cert);
                    store.Close();
                    installed = true;
                    Console.WriteLine($"Certificado instalado en almacén de Máquina Local");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error al instalar en Máquina Local: {ex.Message}");
            }
        }
        else
        {
            // Solo intentar instalar en CurrentUser si no es administrador
            try
            {
                using (var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser))
                {
                    store.Open(OpenFlags.ReadWrite);
                    store.Add(cert);
                    store.Close();
                    installed = true;
                    Console.WriteLine($"Certificado instalado en almacén de Usuario Actual");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error al instalar en Usuario Actual: {ex.Message}");
            }
        }

        if (!installed)
        {
            throw new Exception("No se pudo instalar el certificado en ningún almacén");
        }

        // Confiar explícitamente en el certificado
        proxyServer.CertificateManager.TrustRootCertificate(true);
    }

    private bool IsProxyEnabled()
    {
        try
        {
            const string userRoot = "HKEY_CURRENT_USER";
            const string subKey = @"Software\Microsoft\Windows\CurrentVersion\Internet Settings";
            const string keyName = userRoot + "\\" + subKey;

            var proxyEnabled = Registry.GetValue(keyName, "ProxyEnable", 0);
            var proxyServer = Registry.GetValue(keyName, "ProxyServer", "");

            return (proxyEnabled is int pe && pe == 1) && proxyServer?.ToString() == $"127.0.0.1:{proxyPort}";
        }
        catch
        {
            return false;
        }
    }

    private void ConfigureProxyServer()
    {
        var explicitEndpoint = new ExplicitProxyEndPoint(IPAddress.Any, proxyPort, true);
        proxyServer.AddEndPoint(explicitEndpoint);

        proxyServer.BeforeRequest += OnRequestAsync;
        proxyServer.ServerCertificateValidationCallback += OnCertificateValidation;
        proxyServer.ClientCertificateSelectionCallback += OnCertificateSelection;

        // Asegurar que el proxy reenvíe las solicitudes no coincidentes
        proxyServer.ForwardToUpstreamGateway = true;

        // Deshabilitar conexión al túnel para WebSockets si no es necesario
        proxyServer.EnableConnectionPool = true;

        proxyServer.Start();

        Console.WriteLine($"Proxy running on port {proxyPort} with {endpoints.Count} endpoints.");
    }

    private async Task OnRequestAsync(object sender, SessionEventArgs e)
    {
        var request = e.HttpClient.Request;
        string url = request.RequestUri.ToString();

        var matchingEndpoint = endpoints.Values.FirstOrDefault(ep =>
            ep.IsEnabled && MatchesEndpoint(url, ep) &&
            ep.HttpMethod.Equals(request.Method, StringComparison.OrdinalIgnoreCase));

        if (matchingEndpoint != null)
        {
            try
            {
                LogRequest(request);

                string requestBody = string.Empty;
                if (request.Method.Equals("POST", StringComparison.OrdinalIgnoreCase) ||
                    request.Method.Equals("PUT", StringComparison.OrdinalIgnoreCase) ||
                    request.Method.Equals("PATCH", StringComparison.OrdinalIgnoreCase))
                {
                    requestBody = await e.GetRequestBodyAsString();
                }

                var modifiedResponse = matchingEndpoint.ResponseGenerator();
                string modifiedBody = JsonSerializer.Serialize(modifiedResponse);

                var headers = new Dictionary<string, HttpHeader>
                {
                    { "Content-Type", new HttpHeader("Content-Type", "application/json; charset=utf-8") }
                };

                // Enviar respuesta modificada y cerrar la conexión
                e.Ok(modifiedBody, headers);
                e.UserData = "Handled";

                LogSuccess("Respuesta modificada exitosamente");
            }
            catch (Exception ex)
            {
                LogError("Error al procesar la solicitud", ex);
                throw;
            }
        }
        else
        {
            // Continuar con la solicitud normal
            e.UserData = null;
        }
    }

    private Task OnCertificateSelection(object sender, CertificateSelectionEventArgs e)
    {
        e.ClientCertificate = proxyServer.CertificateManager.RootCertificate;
        return Task.CompletedTask;
    }

    private Task OnCertificateValidation(object sender, CertificateValidationEventArgs e)
    {
        e.IsValid = true;
        return Task.CompletedTask;
    }

    private async Task StartProxyServer()
    {
        if (!proxyServer.ProxyRunning)
        {
            proxyServer.Start();
            await Task.CompletedTask;
        }
    }

    private void PrintStatus()
    {
        Console.WriteLine("Waiting for requests...");
        Console.WriteLine("\nPress ESC to exit");
    }

    private async Task WaitForEscKey()
    {
        while (true)
        {
            if (Console.KeyAvailable)
            {
                var key = Console.ReadKey(true).Key;
                if (key == ConsoleKey.Escape)
                {
                    break;
                }
            }

            await Task.Delay(100);
        }
    }

    private bool MatchesEndpoint(string url, ApiEndpoint endpoint)
    {
        if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))
        {
            return false;
        }

        string host = uri.Host;
        int port = uri.Port;
        string fullHost = port != -1 ? $"{host}:{port}" : host;
        string pathAndQuery = uri.PathAndQuery;

        bool hostMatches = endpoint.MatchType switch
        {
            "EmpiezaPor" or "StartWith" => fullHost.StartsWith(endpoint.HostPattern,
                StringComparison.OrdinalIgnoreCase),
            "TerminaCon" or "EndsWith" => fullHost.EndsWith(endpoint.HostPattern, StringComparison.OrdinalIgnoreCase),
            "Exacto" or "Exact" => fullHost.Equals(endpoint.HostPattern, StringComparison.OrdinalIgnoreCase),
            "Contiene" or "Contains" => fullHost.Contains(endpoint.HostPattern, StringComparison.OrdinalIgnoreCase),
            _ => false
        };

        bool pathMatches = endpoint.MatchType switch
        {
            "EmpiezaPor" or "StartsWith" => pathAndQuery.StartsWith(endpoint.UrlPattern,
                StringComparison.OrdinalIgnoreCase),
            "TerminaCon" or "EndsWith" =>
                pathAndQuery.EndsWith(endpoint.UrlPattern, StringComparison.OrdinalIgnoreCase),
            "Exacto" or "Exact" => pathAndQuery.Equals(endpoint.UrlPattern, StringComparison.OrdinalIgnoreCase),
            "Contiene" or "Contains" => pathAndQuery.Contains(endpoint.UrlPattern, StringComparison.OrdinalIgnoreCase),
            _ => false
        };

        return hostMatches && pathMatches;
    }

    private void LogRequest(Titanium.Web.Proxy.Http.Request request)
    {
        Console.WriteLine($"\nRequest detected: {request.Method} {request.RequestUri}");
        Console.WriteLine("Request headers:");
        foreach (var header in request.Headers)
        {
            Console.WriteLine($"  {header.Name}: {header.Value}");
        }
    }

    private void LogSuccess(string message, string? details = null)
    {
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine($"\n{message}:");
        Console.ResetColor();
        if (details != null)
        {
            Console.WriteLine(details);
        }
    }

    private void LogError(string message, Exception ex)
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine($"\n{message}: {ex.Message}");
        Console.WriteLine(ex.StackTrace);
        Console.ResetColor();
    }

    public void CloseProxy()
    {
        SetWindowsProxy(false);
        Console.WriteLine("Proxy deshabilitado correctamente.");
    }

    public void Dispose()
    {
        try
        {
            if (proxyEnabled)
            {
                SetWindowsProxy(false);
            }

            proxyServer.BeforeRequest -= OnRequestAsync;

            if (proxyServer.ProxyRunning)
            {
                proxyServer.Stop();
            }

            proxyServer.Dispose();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error cleaning up resources: {ex.Message}");
        }
    }
}

public class Rule
{
    public string Name { get; set; }
    public string HostPattern { get; set; }
    public string UrlPattern { get; set; }
    public string MatchType { get; set; }
    public string HttpMethod { get; set; }
    public JsonElement Response { get; set; }
    public bool IsEnabled { get; set; }
}

public class RulesConfig
{
    public List<Rule> Rules { get; set; }
}

class Program
{
    static async Task Main(string[] args)
    {
        // Verificar si se pasó el argumento -Close
        if (args.Contains("-Close", StringComparer.OrdinalIgnoreCase))
        {
            using var proxyManagerClose = new ProxyManager(); // Renombrar la variable aquí
            try
            {
                proxyManagerClose.CloseProxy();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error al deshabilitar el proxy: {ex.Message}");
            }

            return;
        }

        // Verificar si se pasó el argumento -RestoreC
        if (args.Contains("-RestoreC", StringComparer.OrdinalIgnoreCase))
        {
            using var proxyManagerRestore = new ProxyManager();
            try
            {
                proxyManagerRestore.RestoreCertificates();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error al restaurar los certificados: {ex.Message}");
            }

            return;
        }

        // Verificar la existencia del archivo de reglas en el directorio raíz
        string rulesPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "proxy_rules.json");
        if (!File.Exists(rulesPath))
        {
            // Crear un archivo de reglas de ejemplo si no existe
            var exampleRules = new
            {
                rules = new List<object>
                {
                    new
                    {
                        Name = "zorara",
                        HostPattern = "getzorara.online:5000",
                        UrlPattern = "/check_key",
                        MatchType = "Exact",
                        HttpMethod = "GET",
                        Response = new { message = "Key is valid." },
                        IsEnabled = true
                    }
                }
            };
            File.WriteAllText(rulesPath,
                JsonSerializer.Serialize(exampleRules, new JsonSerializerOptions { WriteIndented = true }));
        }

        using var proxyManager = new ProxyManager(); // Variable renombrada no es necesaria aquí
        {
            try
            {
                // Leer el archivo de reglas desde la ruta correcta
                string jsonContent = File.ReadAllText(rulesPath);
                Console.WriteLine("Contenido de proxy_rules.json:");
                Console.WriteLine(jsonContent);

                var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                var rulesConfig = JsonSerializer.Deserialize<RulesConfig>(jsonContent, options);

                if (rulesConfig?.Rules == null)
                {
                    Console.WriteLine("No se pudieron cargar las reglas desde proxy_rules.json.");
                    return;
                }

                foreach (var rule in rulesConfig.Rules)
                {
                    string hostPattern = rule.HostPattern;
                    string formattedUrlPattern = rule.UrlPattern;

                    // Eliminar el protocolo si está presente en UrlPattern
                    if (formattedUrlPattern.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                        formattedUrlPattern.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
                    {
                        var uri = new Uri(formattedUrlPattern);
                        formattedUrlPattern = uri.PathAndQuery;
                    }

                    // Ajustar el ResponseGenerator para manejar JsonElement
                    proxyManager.AddEndpoint(rule.Name, new ApiEndpoint
                    {
                        HostPattern = hostPattern,
                        UrlPattern = formattedUrlPattern,
                        ResponseGenerator = () => JsonSerializer.Deserialize<dynamic>(rule.Response.GetRawText()),
                        HttpMethod = rule.HttpMethod,
                        MatchType = rule.MatchType,
                        IsEnabled = rule.IsEnabled
                    });
                }
            }
            catch (JsonException jsonEx)
            {
                Console.WriteLine($"Error de JSON: {jsonEx.Message}");
                return;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error al cargar las reglas: {ex.Message}");
                return;
            }
        }

        AppDomain.CurrentDomain.ProcessExit += (s, e) => proxyManager.Dispose();

        await proxyManager.StartProxy();
    }
}